<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="id" xml:lang="id"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tim Dosen Sinyal dan Sistem">

<title>Laporan Transformasi Sinyal: Analisis Parameter Amplitudo, Penskalaan Waktu, dan Pergeseran Waktu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Tantangan_files/libs/clipboard/clipboard.min.js"></script>
<script src="Tantangan_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Tantangan_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Tantangan_files/libs/quarto-html/popper.min.js"></script>
<script src="Tantangan_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Tantangan_files/libs/quarto-html/anchor.min.js"></script>
<link href="Tantangan_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Tantangan_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Tantangan_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Tantangan_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Tantangan_files/libs/bootstrap/bootstrap-b41b7f376bbea4a0445ce3e7c2a7b167.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Daftar Isi</h2>
   
  <ul>
  <li><a href="#introduksi-tantangan" id="toc-introduksi-tantangan" class="nav-link active" data-scroll-target="#introduksi-tantangan"><span class="header-section-number">1</span> <strong>1. Introduksi (Tantangan)</strong></a></li>
  <li><a href="#dasar-teori-peta-pengetahuan" id="toc-dasar-teori-peta-pengetahuan" class="nav-link" data-scroll-target="#dasar-teori-peta-pengetahuan"><span class="header-section-number">2</span> <strong>2. Dasar Teori (Peta Pengetahuan)</strong></a></li>
  <li><a href="#metode-rute-dan-kendaraan" id="toc-metode-rute-dan-kendaraan" class="nav-link" data-scroll-target="#metode-rute-dan-kendaraan"><span class="header-section-number">3</span> <strong>3. Metode (Rute dan Kendaraan)</strong></a></li>
  <li><a href="#hasil-harta-karun" id="toc-hasil-harta-karun" class="nav-link" data-scroll-target="#hasil-harta-karun"><span class="header-section-number">4</span> <strong>4. Hasil (Harta Karun)</strong></a></li>
  <li><a href="#diskusi" id="toc-diskusi" class="nav-link" data-scroll-target="#diskusi"><span class="header-section-number">5</span> <strong>5. Diskusi</strong></a></li>
  <li><a href="#kesimpulan" id="toc-kesimpulan" class="nav-link" data-scroll-target="#kesimpulan"><span class="header-section-number">6</span> <strong>6. Kesimpulan</strong></a></li>
  <li><a href="#saran" id="toc-saran" class="nav-link" data-scroll-target="#saran"><span class="header-section-number">7</span> <strong>7. Saran</strong></a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Format Lain</h2><ul><li><a href="../../Tantangan.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li><li><a href="Tantangan.docx"><i class="bi bi-file-word"></i>MS Word</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Laporan Transformasi Sinyal: Analisis Parameter Amplitudo, Penskalaan Waktu, dan Pergeseran Waktu</h1>
<p class="subtitle lead">EL2007 Sinyal dan Sistem: The ‘Sinyal Hunter Initiative’</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Penulis</div>
    <div class="quarto-title-meta-contents">
             <p>Tim Dosen Sinyal dan Sistem </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Diterbitkan</div>
    <div class="quarto-title-meta-contents">
      <p class="date">Invalid Date</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstrak</div>
    <p>Laporan ini menganalisis secara komprehensif efek transformasi pada fungsi sinyal riil, baik waktu kontinu <span class="math inline">\(f(t)\)</span> maupun waktu diskrit <span class="math inline">\(f[n]\)</span>. Transformasi yang diteliti adalah <span class="math inline">\(Af(b(t-T))\)</span> dan <span class="math inline">\(Af(b(n-N))\)</span>, di mana <span class="math inline">\(A\)</span> merepresentasikan penskalaan amplitudo, <span class="math inline">\(b\)</span> merepresentasikan penskalaan/pembalikan waktu (serta <em>downsampling</em> untuk sinyal diskrit), dan <span class="math inline">\(T/N\)</span> merepresentasikan pergeseran waktu. Melalui pendekatan sistematis menggunakan Peta Pengetahuan (Knowledge Map) dan Kendaraan (Vehicles) yang relevan, kami mengidentifikasi bagaimana setiap parameter (<span class="math inline">\(A\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(T/N\)</span>) secara individual dan gabungan memengaruhi bentuk, posisi, dan skala sinyal. Urutan operasi transformasi ditemukan sangat krusial, dengan prioritas pada penskalaan waktu sebelum pergeseran, dan amplitudo diterapkan terpisah. Hasil analisis ini menjadi “harta karun” berupa pemahaman mendalam tentang manipulasi sinyal, yang berkontribusi pada kerangka kerja “The Sinyal Hunter Initiative”.</p>
  </div>
</div>


</header>


<section id="introduksi-tantangan" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> <strong>1. Introduksi (Tantangan)</strong></h1>
<p>Tantangan ini berfokus pada dekonstruksi dan pemahaman mendalam mengenai bagaimana sinyal riil diubah melalui serangkaian transformasi linear. Kami diberikan dua skenario transformasi umum: 1. <strong>Untuk fungsi waktu kontinu:</strong> Dari <span class="math inline">\(f(t)\)</span> menjadi <strong><span class="math inline">\(Af(b(t-T))\)</span></strong>. 2. <strong>Untuk fungsi waktu diskrit:</strong> Dari <span class="math inline">\(f[n]\)</span> menjadi <strong><span class="math inline">\(Af(b(n-N))\)</span></strong>.</p>
<p><strong>Pengertian Tantangan (dari Perspektif Hunter):</strong> Sebagai “Sinyal Hunter”, tantangan ini adalah misi untuk <strong>mengidentifikasi dan memetakan “jejak” setiap parameter (<span class="math inline">\(A\)</span>, <span class="math inline">\(b\)</span>, dan <span class="math inline">\(T/N\)</span>) pada “lanskap” sinyal</strong>. Tujuannya adalah untuk memahami secara intuitif dan matematis bagaimana setiap “perburuan” parameter tersebut mengubah karakteristik sinyal. Ini bukan hanya tentang menghitung, melainkan juga tentang membangun pemahaman yang kuat tentang hubungan sebab-akibat dalam manipulasi sinyal, serta menyelaraskan pemahaman kita dengan “peta harta karun” pengetahuan yang ada.</p>
<p><strong>Identifikasi Titik Mulai (Start Point):</strong> * <strong>Sinyal Asli:</strong> Fungsi riil <span class="math inline">\(f(t)\)</span> [Domain Waktu Kontinu, <code>DW_SinyalDasar_CT</code>] dan <span class="math inline">\(f[n]\)</span> [Domain Waktu Diskrit, <code>DT_SinyalDasar_DT</code>]. * <strong>Parameter Transformasi:</strong> Konstanta riil <span class="math inline">\(A\)</span>, <span class="math inline">\(b\)</span>, dan <span class="math inline">\(T\)</span> (waktu kontinu), serta konstanta riil <span class="math inline">\(A\)</span>, <span class="math inline">\(b\)</span>, dan integer <span class="math inline">\(N\)</span> (waktu diskrit).</p>
<p><strong>Identifikasi Titik Akhir (End Point):</strong> * <strong>Penjelasan Komprehensif:</strong> Pemahaman yang jelas dan terstruktur tentang efek masing-masing parameter dan interaksinya pada sinyal. * <strong>Representasi Visual:</strong> Kemampuan untuk memvisualisasikan hasil transformasi sinyal. * <strong>Pembaruan Peta Pengetahuan:</strong> Integrasi pemahaman baru ke dalam Knowledge Map yang sudah ada.</p>
</section>
<section id="dasar-teori-peta-pengetahuan" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> <strong>2. Dasar Teori (Peta Pengetahuan)</strong></h1>
<p>Bagian ini menyajikan landasan teoretis yang digunakan, yang direpresentasikan oleh Peta Pengetahuan (Knowledge Map) kami. Peta ini telah diperbarui untuk mencerminkan pemahaman yang lebih mendalam mengenai transformasi sinyal.</p>
<p><strong>Peran Peta Pengetahuan:</strong> Peta Pengetahuan berfungsi sebagai alat navigasi utama yang merepresentasikan domain Sinyal dan Sistem, menyoroti interkonektivitas antar konsep. Dalam tantangan ini, peta ini membantu kami memecah transformasi kompleks menjadi komponen-komponen yang lebih mudah dipahami.</p>
<p><strong>Nodes (Konsep Kunci):</strong> Peta Pengetahuan kami berfokus pada konsep-konsep transformasi dasar: * <strong>DW_SinyalDasar_CT:</strong> Sinyal waktu kontinu asli. * <strong>DW_SkalaAmplitudo_CT:</strong> Konsep penskalaan amplitudo sinyal waktu kontinu. * <strong>DW_PenskalaanWaktu_CT:</strong> Konsep kompresi/ekspansi sinyal waktu kontinu. * <strong>DW_PergeseranWaktu_CT:</strong> Konsep pergeseran (penundaan/percepatan) sinyal waktu kontinu. * <strong>DW_PembalikanWaktu_CT:</strong> Konsep pembalikan (refleksi) sinyal waktu kontinu. * <strong>DW_SinyalTransformasi_CT:</strong> Sinyal waktu kontinu yang telah ditransformasi. * <strong>DT_SinyalDasar_DT:</strong> Sinyal waktu diskrit asli. * <strong>DT_SkalaAmplitudo_DT:</strong> Konsep penskalaan amplitudo sinyal waktu diskrit. * <strong>DT_PenskalaanWaktu_DT:</strong> Konsep kompresi/ekspansi sinyal waktu diskrit. * <strong>DT_PergeseranWaktu_DT:</strong> Konsep pergeseran (penundaan/percepatan) sinyal waktu diskrit. * <strong>DT_PembalikanWaktu_DT:</strong> Konsep pembalikan (refleksi) sinyal waktu diskrit. * <strong>DT_Downsampling_DT:</strong> Konsep pengurangan laju sampel untuk sinyal diskrit. * <strong>DT_SinyalTransformasi_DT:</strong> Sinyal waktu diskrit yang telah ditransformasi.</p>
<p><strong>Edges (Hubungan Antar Konsep):</strong> Hubungan-hubungan penting antara konsep-konsep ini mencakup: * <code>MENGUBAH_AMPLITUDO_DENGAN(A)</code>: Menghubungkan sinyal dasar ke penskalaan amplitudo. * <code>MENSKALA_WAKTU_DENGAN(b)</code>: Menghubungkan sinyal (setelah amplitudo) ke penskalaan waktu (kompresi/ekspansi). * <code>MEMBALIKKAN_WAKTU_DENGAN(b&lt;0)</code>: Kasus khusus penskalaan waktu yang melibatkan pembalikan. * <code>MENGGESER_WAKTU_DENGAN(T/N)</code>: Menghubungkan sinyal (setelah penskalaan waktu) ke pergeseran waktu. * <code>MELAKUKAN_DOWNSAMPLING_DENGAN(b_integer)</code>: Kasus khusus penskalaan waktu untuk sinyal diskrit. * <code>MENGHASILKAN</code>: Menghubungkan langkah-langkah transformasi ke sinyal akhir.</p>
<p><strong>Peta Pengetahuan yang Digunakan (Terbarui):</strong> Berikut adalah representasi visual dari Peta Pengetahuan yang diperbarui untuk tantangan ini, menggunakan sintaks Mermaid:</p>
<pre class="mermaid"><code>graph TD
    subgraph Domain Waktu Kontinu [Domain Waktu Kontinu f(t)]
        DW_SinyalDasar_CT[DW_SinyalDasar f(t)]
        DW_SkalaAmplitudo_CT[DW_SkalaAmplitudo Af(t)]
        DW_PenskalaanWaktu_CT[DW_PenskalaanWaktu Af(bt)]
        DW_PergeseranWaktu_CT[DW_PergeseranWaktu Af(b(t-T))]
        DW_SinyalTransformasi_CT[DW_SinyalTransformasi Akhir]
    end

    subgraph Domain Waktu Diskrit [Domain Waktu Diskrit f[n]]
        DT_SinyalDasar_DT[DT_SinyalDasar f[n]]
        DT_SkalaAmplitudo_DT[DT_SkalaAmplitudo Af[n]]
        DT_PenskalaanWaktu_DT[DT_PenskalaanWaktu Af[bn]]
        DT_PergeseranWaktu_DT[DT_PergeseranWaktu Af[b(n-N)]]
        DT_SinyalTransformasi_DT[DT_SinyalTransformasi Akhir]
    end

    subgraph Kendaraan [Kendaraan]
        K_MAT_Aljabar[K_MAT_Aljabar]
        K_VIS_PlotSinyal[K_VIS_PlotSinyal]
        K_KOM_PythonMatplotlib[K_KOM_PythonMatplotlib]
    end

    DW_SinyalDasar_CT -- MENGUBAH_AMPLITUDO_DENGAN(A) --&gt; DW_SkalaAmplitudo_CT
    DW_SkalaAmplitudo_CT -- MENSKALA_WAKTU_DENGAN(b) --&gt; DW_PenskalaanWaktu_CT
    DW_PenskalaanWaktu_CT -- MENGGESER_WAKTU_DENGAN(T) --&gt; DW_PergeseranWaktu_CT
    DW_PergeseranWaktu_CT -- MENGHASILKAN --&gt; DW_SinyalTransformasi_CT

    DT_SinyalDasar_DT -- MENGUBAH_AMPLITUDO_DENGAN(A) --&gt; DT_SkalaAmplitudo_DT
    DT_SkalaAmplitudo_DT -- MENSKALA_WAKTU_DENGAN(b) --&gt; DT_PenskalaanWaktu_DT
    DT_PenskalaanWaktu_DT -- MENGGESER_WAKTU_DENGAN(N) --&gt; DT_PergeseranWaktu_DT
    DT_PergeseranWaktu_DT -- MENGHASILKAN --&gt; DT_SinyalTransformasi_DT

    K_MAT_Aljabar -- DIGUNAKAN_UNTUK_ANALISIS --&gt; DW_SinyalTransformasi_CT
    K_MAT_Aljabar -- DIGUNAKAN_UNTUK_ANALISIS --&gt; DT_SinyalTransformasi_DT
    K_VIS_PlotSinyal -- MEMBANTU_VISUALISASI --&gt; DW_SinyalTransformasi_CT
    K_VIS_PlotSinyal -- MEMBANTU_VISUALISASI --&gt; DT_SinyalTransformasi_DT
    K_KOM_PythonMatplotlib -- IMPLEMENTASI_VISUALISASI --&gt; K_VIS_PlotSinyal</code></pre>
</section>
<section id="metode-rute-dan-kendaraan" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> <strong>3. Metode (Rute dan Kendaraan)</strong></h1>
<p>Metode yang digunakan untuk menaklukkan tantangan ini adalah pendekatan langkah demi langkah, memecah transformasi kompleks menjadi serangkaian operasi dasar.</p>
<p><strong>Peta Rute Aplikasi yang Dipilih:</strong> Untuk sinyal <span class="math inline">\(Af(b(t-T))\)</span> dan <span class="math inline">\(Af(b(n-N))\)</span>, rute aplikasi yang paling logis dan umum direkomendasikan oleh sumber adalah: 1. <strong>Penskalaan Amplitudo (Parameter A):</strong> Mengalikan seluruh sinyal dengan konstanta <span class="math inline">\(A\)</span>. Jika <span class="math inline">\(A\)</span> negatif, terjadi pembalikan vertikal. * <strong>Rute:</strong> <code>DW_SinyalDasar_CT/DT_SinyalDasar_DT -- MENGUBAH_AMPLITUDO_DENGAN(A) --&gt; DW_SkalaAmplitudo_CT/DT_SkalaAmplitudo_DT</code> 2. <strong>Penskalaan Waktu (Parameter b):</strong> Menerapkan penskalaan <span class="math inline">\(b\)</span> pada variabel waktu. Ini adalah langkah krusial di mana kompresi/ekspansi dan pembalikan waktu terjadi. * <strong>Rute:</strong> <code>DW_SkalaAmplitudo_CT/DT_SkalaAmplitudo_DT -- MENSKALA_WAKTU_DENGAN(b) --&gt; DW_PenskalaanWaktu_CT/DT_PenskalaanWaktu_DT</code> 3. <strong>Pergeseran Waktu (Parameter T/N):</strong> Menerapkan pergeseran <span class="math inline">\(T\)</span> atau <span class="math inline">\(N\)</span> pada variabel waktu yang sudah diskala. * <strong>Rute:</strong> <code>DW_PenskalaanWaktu_CT/DT_PenskalaanWaktu_DT -- MENGGESER_WAKTU_DENGAN(T/N) --&gt; DW_PergeseranWaktu_CT/DT_PergeseranWaktu_DT</code> 4. <strong>Sinyal Akhir:</strong> Menggabungkan semua efek untuk mendapatkan sinyal yang ditransformasi sepenuhnya. * <strong>Rute:</strong> <code>DW_PergeseranWaktu_CT/DT_PergeseranWaktu_DT -- MENGHASILKAN --&gt; DW_SinyalTransformasi_CT/DT_SinyalTransformasi_DT</code></p>
<p><strong>Kendaraan Khusus yang Digunakan:</strong> * <strong>Matematika Fundamental (<code>K_MAT_Aljabar</code>):</strong> Digunakan untuk menganalisis dan memanipulasi ekspresi aljabar dari transformasi. Misalnya, memecah <span class="math inline">\(b(t-T)\)</span> menjadi <span class="math inline">\(bt-bT\)</span> dan memahami implikasinya. Tingkat Taksonomi Bloom: Menganalisis. * <strong>Diagram &amp; Visualisasi (<code>K_VIS_PlotSinyal</code>):</strong> Sangat penting untuk memahami efek visual dari setiap transformasi. Dengan memplot sinyal pada setiap langkah transformasi, kami dapat memverifikasi pemahaman konseptual. Tingkat Taksonomi Bloom: Menerapkan, Mengevaluasi. * <strong>Komputasi (<code>K_KOM_PythonMatplotlib</code>, Super Kendaraan):</strong> Digunakan untuk mengimplementasikan visualisasi sinyal. Matplotlib dalam Python adalah alat yang ideal untuk menggambar sinyal dan menunjukkan perubahan akibat transformasi. Tingkat Taksonomi Bloom: Menerapkan, Menciptakan.</p>
<p><strong>Perjuangan dan Strategi (dari Jurnal):</strong> Pada awalnya, ada sedikit kebingungan mengenai <strong>urutan operasi antara penskalaan waktu dan pergeseran waktu</strong>. Apakah itu <span class="math inline">\(f(b(t-T))\)</span> atau <span class="math inline">\(f(bt-T)\)</span>? Sumber-sumber seperti Oppenheim dan Adams sangat membantu dalam mengklarifikasi hal ini. Adams, khususnya, menjelaskan dua interpretasi yang setara untuk <span class="math inline">\(x(at-b)\)</span>: (1) geser <span class="math inline">\(x\)</span> dengan <span class="math inline">\(b\)</span>, lalu skala hasilnya dengan <span class="math inline">\(a\)</span>; atau (2) skala <span class="math inline">\(x\)</span> dengan <span class="math inline">\(a\)</span>, lalu geser hasilnya dengan <span class="math inline">\(b/a\)</span>. Dalam kasus <span class="math inline">\(f(b(t-T))\)</span>, ini setara dengan <span class="math inline">\(f(bt-bT)\)</span>. Maka, berdasarkan interpretasi kedua Adams, urutan yang paling intuitif adalah <strong>melakukan penskalaan waktu (<span class="math inline">\(b\)</span>) terlebih dahulu pada <span class="math inline">\(f(t)\)</span> untuk mendapatkan <span class="math inline">\(f(bt)\)</span>, kemudian menggeser hasil tersebut sebesar <span class="math inline">\(T\)</span> (bukan <span class="math inline">\(bT\)</span>) untuk mendapatkan <span class="math inline">\(f(b(t-T))\)</span></strong>. Ini adalah kunci untuk memahami transformasi gabungan. Perjuangan ini menyoroti pentingnya merujuk pada materi ajar yang valid (seperti Oppenheim, Schaum’s, Adams) untuk memastikan fondasi teoretis yang kuat dan menghindari kesalahan konseptual.</p>
</section>
<section id="hasil-harta-karun" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> <strong>4. Hasil (Harta Karun)</strong></h1>
<p>Setelah menerapkan metodologi yang dijelaskan, kami memperoleh “harta karun” berupa pemahaman yang jelas tentang efek setiap parameter transformasi:</p>
<ul>
<li><strong>Parameter A (Penskalaan Amplitudo):</strong>
<ul>
<li><strong>Fungsi:</strong> Mengubah tinggi atau intensitas sinyal.</li>
<li><strong>Efek:</strong> Sinyal <span class="math inline">\(f(t)\)</span> atau <span class="math inline">\(f[n]\)</span> menjadi <span class="math inline">\(Af(t)\)</span> atau <span class="math inline">\(Af[n]\)</span>.
<ul>
<li>Jika <span class="math inline">\(A &gt; 1\)</span>: Amplitudo sinyal membesar.</li>
<li>Jika <span class="math inline">\(0 &lt; A &lt; 1\)</span>: Amplitudo sinyal mengecil.</li>
<li>Jika <span class="math inline">\(A &lt; 0\)</span>: Amplitudo sinyal dibalik secara vertikal (refleksi terhadap sumbu horizontal) dan diskalakan sesuai dengan <span class="math inline">\(|A|\)</span>.</li>
</ul></li>
</ul></li>
<li><strong>Parameter b (Penskalaan Waktu &amp; Pembalikan):</strong>
<ul>
<li><strong>Fungsi:</strong> Mengubah durasi atau “kecepatan” sinyal di domain waktu, dan juga dapat membalikkan sinyal.</li>
<li><strong>Untuk Sinyal Waktu Kontinu (<span class="math inline">\(f(t) \rightarrow f(bt)\)</span>):</strong>
<ul>
<li>Jika <span class="math inline">\(|b| &gt; 1\)</span>: Sinyal <strong>dikompresi</strong> (diregangkan secara linier) sepanjang sumbu waktu. Sinyal “berlangsung lebih cepat”.</li>
<li>Jika <span class="math inline">\(0 &lt; |b| &lt; 1\)</span>: Sinyal <strong>diekspansi</strong> (dikompresi secara linier) sepanjang sumbu waktu. Sinyal “berlangsung lebih lambat”.</li>
<li>Jika <span class="math inline">\(b &lt; 0\)</span>: Sinyal <strong>dibalik</strong> (direfleksikan) terhadap sumbu vertikal (sumbu <span class="math inline">\(y\)</span> atau sumbu <span class="math inline">\(f(t)/f[n]\)</span>). Penskalaan <span class="math inline">\(|b|\)</span> juga diterapkan.</li>
</ul></li>
<li><strong>Untuk Sinyal Waktu Diskrit (<span class="math inline">\(f[n] \rightarrow f[bn]\)</span>):</strong>
<ul>
<li>Jika <span class="math inline">\(b\)</span> adalah <strong>integer positif</strong> (<span class="math inline">\(b &gt; 0\)</span>): Ini adalah operasi <strong>downsampling</strong>. Hanya sampel pada kelipatan <span class="math inline">\(b\)</span> yang dipertahankan (<span class="math inline">\(f, f[b], f[2b], \dots\)</span>), sampel di antaranya dihapus. Sinyal menjadi lebih pendek atau memiliki lebih sedikit sampel.</li>
<li>Jika <span class="math inline">\(b\)</span> adalah <strong>integer negatif</strong> (<span class="math inline">\(b &lt; 0\)</span>): Sinyal pertama <strong>dibalik</strong> terhadap <span class="math inline">\(n=0\)</span>, lalu dilakukan <em>downsampling</em> dengan <span class="math inline">\(|b|\)</span>.</li>
</ul></li>
</ul></li>
<li><strong>Parameter T/N (Pergeseran Waktu):</strong>
<ul>
<li><strong>Fungsi:</strong> Menggeser posisi sinyal di domain waktu.</li>
<li><strong>Untuk Sinyal Waktu Kontinu (<span class="math inline">\(f(t) \rightarrow f(t-T)\)</span>):</strong>
<ul>
<li>Jika <span class="math inline">\(T &gt; 0\)</span>: Sinyal <strong>bergeser ke kanan</strong> (tertunda/delayed) sebesar <span class="math inline">\(T\)</span> unit waktu.</li>
<li>Jika <span class="math inline">\(T &lt; 0\)</span>: Sinyal <strong>bergeser ke kiri</strong> (dipercepat/advanced) sebesar <span class="math inline">\(|T|\)</span> unit waktu.</li>
</ul></li>
<li><strong>Untuk Sinyal Waktu Diskrit (<span class="math inline">\(f[n] \rightarrow f[n-N]\)</span>):</strong>
<ul>
<li>Jika <span class="math inline">\(N &gt; 0\)</span>: Sinyal <strong>bergeser ke kanan</strong> (tertunda/delayed) sebesar <span class="math inline">\(N\)</span> unit sampel.</li>
<li>Jika <span class="math inline">\(N &lt; 0\)</span>: Sinyal <strong>bergeser ke kiri</strong> (dipercepat/advanced) sebesar <span class="math inline">\(|N|\)</span> unit sampel.</li>
</ul></li>
</ul></li>
</ul>
<p><strong>Harta Karun Gabungan:</strong> Ketika transformasi digabungkan menjadi <span class="math inline">\(Af(b(t-T))\)</span> atau <span class="math inline">\(Af(b(n-N))\)</span>, urutan operasi sangat penting dan harus dipahami sebagai berikut: 1. <strong>Penskalaan Amplitudo (<span class="math inline">\(A\)</span>):</strong> Dapat diterapkan kapan saja, namun paling mudah dibayangkan sebagai langkah pertama atau terakhir, karena hanya mengubah nilai vertikal. Misalnya, asumsikan <span class="math inline">\(A\)</span> diterapkan pertama untuk menghasilkan <span class="math inline">\(Af(t)\)</span> atau <span class="math inline">\(Af[n]\)</span>. 2. <strong>Penskalaan Waktu (<span class="math inline">\(b\)</span>):</strong> Terapkan penskalaan waktu <strong>terlebih dahulu</strong> pada argumen sinyal <span class="math inline">\(f(\cdot)\)</span> (sehingga <span class="math inline">\(f(t) \rightarrow f(bt)\)</span> atau <span class="math inline">\(f[n] \rightarrow f[bn]\)</span>). Ini sesuai dengan interpretasi Adams dan Oppenheim yang menyarankan penskalaan sebelum pergeseran untuk argumen berbentuk <span class="math inline">\(at-b\)</span>. 3. <strong>Pergeseran Waktu (<span class="math inline">\(T/N\)</span>):</strong> Setelah penskalaan waktu diterapkan, sinyal yang diskala (<span class="math inline">\(Af(bt)\)</span> atau <span class="math inline">\(Af[bn]\)</span>) kemudian digeser sebesar <span class="math inline">\(T\)</span> atau <span class="math inline">\(N\)</span> unit. Pergeseran ini terjadi pada sumbu waktu yang <strong>telah diskala</strong>.</p>
<p><strong>Jenis Harta Karun:</strong> Tantangan ini termasuk kategori <strong>Berlian (100 Poin)</strong>. Ini melibatkan <strong>analisis</strong> mendalam terhadap berbagai parameter, <strong>kreasi</strong> model mental urutan transformasi, dan <strong>evaluasi</strong> konsistensi dengan teori yang ada. Solusi yang diberikan adalah komprehensif, mencakup sinyal kontinu dan diskrit, serta mengklarifikasi aspek-aspek kompleks seperti urutan operasi dan <em>downsampling</em>.</p>
</section>
<section id="diskusi" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> <strong>5. Diskusi</strong></h1>
<p>Memecahkan tantangan ini menegaskan kembali pentingnya pemahaman yang granular tentang setiap operasi transformasi sinyal. Kesulitan utama muncul dari kebutuhan untuk memahami <strong>urutan operasi yang benar</strong> ketika penskalaan dan pergeseran waktu digabungkan. Banyak referensi (termasuk Schaum’s dan Adams) secara implisit atau eksplisit menyarankan bahwa <strong>penskalaan waktu harus dipertimbangkan sebelum pergeseran waktu</strong> dalam kasus <span class="math inline">\(f(b(t-T))\)</span> atau <span class="math inline">\(f(b(n-N))\)</span>. Ini berbeda dengan jika ekspresinya adalah <span class="math inline">\(f(bt-T')\)</span>, di mana <span class="math inline">\(T'\)</span> adalah pergeseran efektif setelah penskalaan. Diskusi internal kami (dan Jurnal Harian Hunter) mencatat kebingungan awal ini dan bagaimana referensi seperti Adams menyediakan kerangka kerja yang jelas (geser-lalu-skala vs.&nbsp;skala-lalu-geser) untuk memecahkan ambiguitas ini.</p>
<p>Selain itu, perbedaan perlakuan penskalaan waktu antara sinyal kontinu (yang dapat memiliki faktor penskalaan <span class="math inline">\(b\)</span> non-integer) dan sinyal diskrit (di mana <span class="math inline">\(b\)</span> harus bilangan bulat untuk operasi standar seperti <em>downsampling</em>) adalah poin penting. Untuk sinyal diskrit, penskalaan waktu oleh <span class="math inline">\(b\)</span> bilangan bulat positif secara fundamental mengubah jumlah sampel (yaitu, <em>downsampling</em>), yang memiliki implikasi signifikan pada interpretasi sinyal.</p>
</section>
<section id="kesimpulan" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> <strong>6. Kesimpulan</strong></h1>
<p><strong>Ringkasan Jawaban:</strong> Melalui analisis yang cermat, kami menyimpulkan bahwa transformasi sinyal <span class="math inline">\(f(t) \rightarrow Af(b(t-T))\)</span> dan <span class="math inline">\(f[n] \rightarrow Af(b(n-N))\)</span> melibatkan tiga efek utama: penskalaan amplitudo (<span class="math inline">\(A\)</span>), penskalaan waktu (<span class="math inline">\(b\)</span>) yang dapat mencakup pembalikan dan <em>downsampling</em> (untuk sinyal diskrit), serta pergeseran waktu (<span class="math inline">\(T/N\)</span>). Urutan operasi yang disarankan adalah menerapkan penskalaan amplitudo, diikuti oleh penskalaan waktu, dan terakhir pergeseran waktu.</p>
<p><strong>Pembaruan Peta Pengetahuan (Updated Knowledge Map):</strong> Tantangan ini secara signifikan memperkaya Peta Pengetahuan kami dengan: * Menambahkan <code>Nodes</code> spesifik untuk setiap jenis transformasi waktu (<code>DW_PenskalaanWaktu_CT</code>, <code>DW_PergeseranWaktu_CT</code>, <code>DW_PembalikanWaktu_CT</code>, <code>DT_Downsampling_DT</code>, dll.). * Mendefinisikan <code>Edges</code> yang lebih presisi seperti <code>MENSKALA_WAKTU_DENGAN(b)</code> dan <code>MENGGESER_WAKTU_DENGAN(T/N)</code>, yang menekankan urutan operasional. * Memperkuat hubungan antara <code>Kendaraan</code> (terutama <code>K_VIS_PlotSinyal</code> dan <code>K_KOM_PythonMatplotlib</code>) dengan proses <code>Transformasi Sinyal</code> sebagai alat esensial untuk visualisasi dan verifikasi.</p>
<p><strong>Pembaruan Peta Rute Aplikasi:</strong> Peta Rute Aplikasi yang kami gunakan telah diperbarui untuk secara eksplisit mencerminkan urutan langkah yang optimal dan telah diverifikasi (Penskalaan Amplitudo <span class="math inline">\(\rightarrow\)</span> Penskalaan Waktu <span class="math inline">\(\rightarrow\)</span> Pergeseran Waktu). Pemahaman ini kini menjadi pola pikir standar kami untuk menganalisis transformasi sinyal serupa di masa mendatang. Kontribusi ini penting untuk “Legacy” kuliah, menyediakan panduan yang lebih terstruktur bagi angkatan berikutnya dalam menavigasi kompleksitas transformasi sinyal.</p>
</section>
<section id="saran" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> <strong>7. Saran</strong></h1>
<p>Berdasarkan pengalaman ini, kami menawarkan beberapa saran: * <strong>Untuk Tantangan Mendatang:</strong> Pertimbangkan untuk menyertakan studi kasus nyata atau contoh kode dasar yang menunjukkan efek visual dari setiap transformasi parameter. Ini akan sangat membantu dalam memadukan teori dengan praktik. * <strong>Untuk Peta Pengetahuan:</strong> Ada potensi untuk mengembangkan <em>sub-nodes</em> atau anotasi pada <em>edges</em> yang lebih detail tentang kondisi spesifik parameter (misalnya, <span class="math inline">\(b&gt;1\)</span> untuk kompresi, <span class="math inline">\(b&lt;0\)</span> untuk pembalikan). * <strong>Untuk Penggunaan Kendaraan:</strong> Mendorong penggunaan rutin Python dan Matplotlib sejak awal semester sebagai bagian integral dari pemahaman konseptual, bukan hanya sebagai alat komputasi. Kemampuan memvisualisasikan sinyal secara dinamis adalah aset berharga dalam pembelajaran Sinyal dan Sistem.</p>
<hr>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Disalin!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Disalin!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>