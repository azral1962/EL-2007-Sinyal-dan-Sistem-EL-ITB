<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.5.55">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


    <title>petapengetahuan</title>
    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        width: 0.8em;
        margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
        vertical-align: middle;
      }
    </style>

    <style>
      body.hypothesis-enabled #quarto-embed-header {
        padding-right: 36px;
      }

      #quarto-embed-header {
        height: 3em;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: solid 1px;
      }

      #quarto-embed-header h6 {
        font-size: 1.1em;
        padding-top: 0.6em;
        margin-left: 1em;
        margin-right: 1em;
        font-weight: 400;
      }

      #quarto-embed-header a.quarto-back-link,
      #quarto-embed-header a.quarto-download-embed {
        font-size: 0.8em;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-left: 1em;
        margin-right: 1em;
      }

      .quarto-back-container {
        padding-left: 0.5em;
        display: flex;
      }

      .headroom {
          will-change: transform;
          transition: transform 200ms linear;
      }

      .headroom--pinned {
          transform: translateY(0%);
      }

      .headroom--unpinned {
          transform: translateY(-100%);
      }      
    </style>

    <script>
    window.document.addEventListener("DOMContentLoaded", function () {

      var header = window.document.querySelector("#quarto-embed-header");
      const titleBannerEl = window.document.querySelector("body > #title-block-header");
      if (titleBannerEl) {
        titleBannerEl.style.paddingTop = header.clientHeight + "px";
      }
      const contentEl = window.document.getElementById('quarto-content');
      for (const child of contentEl.children) {
        child.style.paddingTop = header.clientHeight + "px";
        child.style.marginTop = "1em";
      }

      // Use the article root if the `back` call doesn't work. This isn't perfect
      // but should typically work
      window.quartoBackToArticle = () => {
        var currentUrl = window.location.href;
        window.history.back();
        setTimeout(() => {
            // if location was not changed in 100 ms, then there is no history back
            if(currentUrl === window.location.href){              
                // redirect to site root
                window.location.href = "index.html";
            }
        }, 100);
      }

      const headroom = new window.Headroom(header, {
        tolerance: 5,
        onPin: function () {
        },
        onUnpin: function () {
        },
      });
      headroom.init();
    });
    </script>

    
<script src="site_libs/manuscript-notebook/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script> 
      </head>

  <body class="quarto-notebook">
    <div id="quarto-embed-header" class="headroom fixed-top bg-primary">
      
      <a onclick="window.quartoBackToArticle(); return false;" class="btn btn-primary quarto-back-link" href=""><i class="bi bi-caret-left"></i> Back to Article</a>
      <h6><i class="bi bi-journal-code"></i> Bentuk ABCD dari Pengetahuan</h6>

            <a href="./PetaPengetahuan.qmd" class="btn btn-primary quarto-download-embed" download="PetaPengetahuan.qmd">Download Source</a>
          </div>

     <div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#bentuk-abcd-dari-pengetahuan" id="toc-bentuk-abcd-dari-pengetahuan" class="nav-link active" data-scroll-target="#bentuk-abcd-dari-pengetahuan">Bentuk ABCD dari Pengetahuan</a></li>
  <li><a href="#peta-pengetahuan-primitif-primitive-knowledge-map" id="toc-peta-pengetahuan-primitif-primitive-knowledge-map" class="nav-link" data-scroll-target="#peta-pengetahuan-primitif-primitive-knowledge-map">Peta Pengetahuan Primitif (Primitive Knowledge Map)</a>
  <ul class="collapse">
  <li><a href="#peta-ringkasan-konsep-dasar" id="toc-peta-ringkasan-konsep-dasar" class="nav-link" data-scroll-target="#peta-ringkasan-konsep-dasar">Peta Ringkasan Konsep Dasar</a></li>
  <li><a href="#penjelasan-diagram-peta-pengetahuan-primitif" id="toc-penjelasan-diagram-peta-pengetahuan-primitif" class="nav-link" data-scroll-target="#penjelasan-diagram-peta-pengetahuan-primitif">Penjelasan Diagram Peta Pengetahuan Primitif:</a></li>
  </ul></li>
  <li><a href="#peta-pemecahan-masalah-problem-solving-knowledge-map" id="toc-peta-pemecahan-masalah-problem-solving-knowledge-map" class="nav-link" data-scroll-target="#peta-pemecahan-masalah-problem-solving-knowledge-map">Peta Pemecahan Masalah (Problem-Solving Knowledge Map)</a>
  <ul class="collapse">
  <li><a href="#peta-ringkasan-pemecahan-masalah" id="toc-peta-ringkasan-pemecahan-masalah" class="nav-link" data-scroll-target="#peta-ringkasan-pemecahan-masalah">Peta Ringkasan Pemecahan Masalah</a></li>
  <li><a href="#penjelasan-diagram-peta-pemecahan-masalah" id="toc-penjelasan-diagram-peta-pemecahan-masalah" class="nav-link" data-scroll-target="#penjelasan-diagram-peta-pemecahan-masalah">Penjelasan Diagram Peta Pemecahan Masalah</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">      <section id="bentuk-abcd-dari-pengetahuan" class="level2">
<h2 class="anchored" data-anchor-id="bentuk-abcd-dari-pengetahuan">Bentuk ABCD dari Pengetahuan</h2>
<p>Suatu pengetahuan dapat dinyatakan dalam pernyataan, misalnya pernyaataan berbentuk ABCD: (A)ctor (B)ehaves under a (C)onditioning system to a (D)egree. Misalnya sebuah fenomena sebuah batang dengan panjang <span class="math inline">\(L_0\)</span> pada suhu <span class="math inline">\(t_0\)</span> akan mengalami perubahan panjang menjadi <span class="math inline">\(L_1\)</span> pada temperatur <span class="math inline">\(t_1\)</span>, menurut <span class="math display">\[\varDelta L = L_1 - L_0 = \alpha (t_1 - t_0) = \alpha \varDelta\]</span> dimana Q adalah koefisien muai panjang.</p>
<p>Dalam format ABCD prinsip ini dapat ditulis 1. <strong>BATANG-MEMUAI-DIPANASKAN-LINIER</strong></p>
<pre><code>- **A**ktor: Batang
    
- **B**erperilaku: memuai
    
- **C**ondisi: dipanaskan $\delta T$
    
- **D**erajat: $\varDelta L = \alpha \varDelta t$
    
- **Pernyataan Lengkap:** Ketika suatu zat dipanaskan, partikel-partikel penyusunnya akan bergerak lebih aktif, menyebabkan benda tersebut memuai atau memanjang.&nbsp;Koefisien muai panjang adalah angka yang menggambarkan seberapa besar pemuaian tersebut untuk setiap derajat Celcius kenaikan suhu.&nbsp;.</code></pre>
<ul>
<li><p><strong>Contoh Koefisien Muai Panjang Beberapa Bahan:</strong></p></li>
<li><p>Aluminium: 24 x 10⁻⁶ /°C&nbsp;</p></li>
<li><p>Kuningan: 19 x 10⁻⁶ /°C&nbsp;</p></li>
<li><p>Tembaga: 17 x 10⁻⁶ /°C&nbsp;</p></li>
<li><p>Baja: 11 x 10⁻⁶ /°C&nbsp;</p></li>
<li><p>Kaca Pyrex: 3 x 10⁻⁶ /°C&nbsp;</p></li>
<li><p>Kaca biasa: 9 x 10⁻⁶ /°C</p></li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
</colgroup>
<tbody>
<tr class="odd">
<td>Berikut ini kita akan mengidentifikasi pernyataan ABCD (Actor Behaves under a Condition to a certain Degree) dari laporan dan menyusunnya dalam daftar dengan label mnemonik untuk kemudahan mengingat dan pengindeksan.</td>
</tr>
<tr class="even">
<td>Setelah itu, kitaa akan membuat diagram konseptual untuk Peta Pengetahuan Primitif dan Peta Pemecahan Masalah menggunakan sintaks Mermaid, berdasarkan informasi dari sumber yang diberikan. Diagram ini bertujuan untuk memvisualisasikan komponen utama dan hubungan di antara mereka.</td>
</tr>
<tr class="odd">
<td>## Garis Besar Sinyal Sistem Berbentunk Pernyataan ABCD</td>
</tr>
<tr class="even">
<td>Berikut adalah daftar pernyataan ABCD yang ditemukan dalam laporan:</td>
</tr>
<tr class="odd">
<td>1. <strong>SISTEM-PROSES-INPUT-OUTPUT</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Sistem</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: memproses</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: sinyal input</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: menghasilkan sinyal output</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Sistem memproses sinyal input untuk menghasilkan sinyal output.</td>
</tr>
<tr class="odd">
<td>2. <strong>CARI-OUTPUT-INPUT-SISTEM-DIKETAHUI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Analis/Insinyur (tersirat)</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: mencari sinyal output</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: sinyal input dan karakteristik sistem diketahui</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: (dengan sukses)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> (Analis/Insinyur) mencari sinyal output ketika sinyal input dan karakteristik sistem diketahui.</td>
</tr>
<tr class="odd">
<td>3. <strong>CARI-SISTEM-INPUT-OUTPUT-DIKETAHUI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Analis/Insinyur (tersirat)</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: mencari karakteristik sistem</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: sinyal input dan sinyal output diketahui</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: (dengan sukses)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> (Analis/Insinyur) mencari karakteristik sistem ketika sinyal input dan sinyal output diketahui.</td>
</tr>
<tr class="odd">
<td>4. <strong>CARI-INPUT-SISTEM-OUTPUT-DIKETAHUI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Analis/Insinyur (tersirat)</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: mencari sinyal input</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: karakteristik sistem dan sinyal output diketahui</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: (dengan sukses)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> (Analis/Insinyur) mencari sinyal input ketika karakteristik sistem dan sinyal output diketahui.</td>
</tr>
<tr class="odd">
<td>5. <strong>SISTEM-KAUSAL-OUTPUT-MASA-LALU</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Sebuah sistem</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: disebut kausal</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: jika outputnya pada waktu tertentu hanya bergantung pada nilai input dan/atau output pada waktu saat ini atau sebelumnya, tanpa bergantung pada nilai input atau output di masa depan</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: (sepenuhnya)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Sebuah sistem disebut kausal (non-antisipatif) jika outputnya pada waktu tertentu hanya bergantung pada nilai input dan/atau output pada waktu saat ini atau sebelumnya, tanpa bergantung pada nilai input atau output di masa depan.</td>
</tr>
<tr class="odd">
<td>6. <strong>SISTEM-FISIK-REALTIME-KAUSAL</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Sistem fisik</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: harus bersifat kausal</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (agar dapat) diimplementasikan secara real-time</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: (sepenuhnya)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Sistem fisik yang dapat diimplementasikan secara real-time harus bersifat kausal.</td>
</tr>
<tr class="odd">
<td>7. <strong>TRANSFORMASI-JEMBATAN-DOMAIN-PERUBAHAN</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Transformasi (Fourier, Laplace, Z)</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: berfungsi sebagai jembatan</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (ketika diterapkan)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: mengubah representasi sinyal dan sistem dari satu domain ke domain lain</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Transformasi seperti Transformasi Fourier, Transformasi Laplace, dan Transformasi Z berfungsi sebagai jembatan, mengubah representasi sinyal dan sistem dari satu domain ke domain lain.</td>
</tr>
<tr class="odd">
<td>8. <strong>TRANSFORMASI-TUJUAN-PENYEDERHANAAN</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Transformasi ini</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: bertujuan</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (ketika digunakan)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: menyederhanakan analisis dan pemecahan masalah</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Tujuan utama dari transformasi ini adalah untuk menyederhanakan analisis dan pemecahan masalah.</td>
</tr>
<tr class="odd">
<td>9. <strong>SINYAL-CT-PERIODIK-DEFINISI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Suatu sinyal waktu kontinu x(t)</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: dikatakan periodik</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: jika x(t + T) = x(t) untuk semua nilai t, dari −∞ &lt; t &lt; ∞</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: (sepenuhnya)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Suatu sinyal waktu kontinu x(t) dikatakan periodik terhadap waktu dengan periode T jika x(t + T) = x(t) untuk semua nilai t, dari −∞ &lt; t &lt; ∞.</td>
</tr>
<tr class="odd">
<td>10. <strong>SISTEM-LINEAR-SUPERPOSISI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Sistem linear</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: memenuhi</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (jika) respons terhadap kombinasi linear input adalah kombinasi linear dari respons terhadap setiap input secara terpisah</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: prinsip superposisi</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Sistem linear memenuhi prinsip superposisi.</td>
</tr>
<tr class="odd">
<td>11. <strong>SISTEM-INVARIAN-WAKTU-KARAKTERISTIK</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Sistem invarian waktu</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: memiliki karakteristik</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (jika) tidak berubah seiring waktu</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: (sepenuhnya)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Sistem invarian waktu memiliki karakteristik yang tidak berubah seiring waktu.</td>
</tr>
<tr class="odd">
<td>12. <strong>SISTEM-BIBO-STABIL-OUTPUT-TERBATAS</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Sistem stabil BIBO</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: menjamin</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: jika input yang diberikan terbatas (bounded)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: output yang dihasilkan juga akan terbatas</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Sistem stabil BIBO menjamin bahwa jika input yang diberikan terbatas (bounded), maka output yang dihasilkan juga akan terbatas.</td>
</tr>
<tr class="odd">
<td>13. <strong>CTFS-REPRESENTASI-SINYAL-PERIODIK</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Deret Fourier Waktu Kontinu (CTFS)</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: digunakan</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: untuk sinyal waktu kontinu yang periodik</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: sebagai penjumlahan tak hingga dari eksponensial kompleks yang berhubungan secara harmonis</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Deret Fourier Waktu Kontinu (CTFS) digunakan untuk merepresentasikan sinyal waktu kontinu yang <strong>periodik</strong> sebagai penjumlahan tak hingga dari eksponensial kompleks yang berhubungan secara harmonis.</td>
</tr>
<tr class="odd">
<td>14. <strong>CTFT-UBAH-WAKTU-FREKUENSI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Transformasi Fourier Waktu Kontinu (CTFT)</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: mengubah</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: sinyal waktu kontinu (f(t))</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: menjadi representasi domain frekuensi kontinu (X(jω) atau X(Ω))</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Transformasi Fourier Waktu Kontinu (CTFT) adalah alat matematis yang mengubah sinyal waktu kontinu (f(t)) menjadi representasi domain frekuensi kontinu (X(jω) atau X(Ω)).</td>
</tr>
<tr class="odd">
<td>15. <strong>CTFT-KONVOLUSI-PERKALIAN</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: CTFT</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: mengubah</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: operasi konvolusi di domain waktu</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: menjadi perkalian sederhana di domain frekuensi</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Properti kunci CTFT mengubah operasi konvolusi di domain waktu menjadi perkalian sederhana di domain frekuensi.</td>
</tr>
<tr class="odd">
<td>16. <strong>LAPLACE-UBAH-WAKTU-S-DOMAIN</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Transformasi Laplace</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: mengubah</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: fungsi waktu kontinu (f(t))</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: menjadi fungsi variabel kompleks (F(s)) di s-domain</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Transformasi Laplace mengubah fungsi waktu kontinu (f(t)) menjadi fungsi variabel kompleks (F(s)) di s-domain atau s-plane.</td>
</tr>
<tr class="odd">
<td>17. <strong>SISTEM-STABIL-POLE-KIRI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Sistem</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: dikatakan stabil</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: jika semua pole-nya terletak di bidang kiri kompleks (yaitu, bagian real dari setiap pole adalah negatif)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: (sepenuhnya)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Sistem dikatakan stabil jika semua pole-nya terletak di bidang kiri kompleks.</td>
</tr>
<tr class="odd">
<td>18. <strong>Z-TRANSFORM-UBAH-WAKTU-Z-DOMAIN</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Transformasi Z</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: mengubah</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: sinyal waktu diskrit (x[n])</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: menjadi representasi domain kompleks (X(z)) di z-domain</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Transformasi Z mengubah sinyal waktu diskrit (x[n]) menjadi representasi domain kompleks (X(z)) di z-domain atau z-plane.</td>
</tr>
<tr class="odd">
<td>19. <strong>SISTEM-STABIL-POLE-UNIT-LINGKARAN</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Sistem</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: dikatakan stabil</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: jika semua pole-nya berada <em>di dalam</em> lingkaran unit (lingkaran dengan radius satu yang berpusat di titik asal) di z-plane</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: (sepenuhnya)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Sistem dikatakan stabil jika semua pole-nya berada <em>di dalam</em> lingkaran unit (lingkaran dengan radius satu yang berpusat di titik asal) di z-plane.</td>
</tr>
<tr class="odd">
<td>20. <strong>SAMPLING-HINDARI-ALIASING-NYQUIST</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Frekuensi sampling</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: harus memenuhi</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: untuk menghindari distorsi yang dikenal sebagai aliasing</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: kriteria yang ditetapkan oleh teorema Nyquist-Shannon</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Untuk menghindari distorsi yang dikenal sebagai aliasing, frekuensi sampling harus memenuhi kriteria yang ditetapkan oleh teorema Nyquist-Shannon.</td>
</tr>
<tr class="odd">
<td>21. <strong>ALIASING-FREKUENSI-RENDAH-DISTORSI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Salinan-salinan spektrum</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: akan tumpang tindih</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: jika frekuensi sampling terlalu rendah</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: menyebabkan frekuensi tinggi “menyamar” sebagai frekuensi rendah dan mengakibatkan hilangnya informasi yang tidak dapat dipulihkan</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Jika frekuensi sampling terlalu rendah, salinan-salinan spektrum ini akan tumpang tindih, menyebabkan frekuensi tinggi “menyamar” sebagai frekuensi rendah dan mengakibatkan hilangnya informasi yang tidak dapat dipulihkan.</td>
</tr>
<tr class="odd">
<td>22. <strong>OUTPUT-CT-LTI-KONVOLUSI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Output y(t)</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: adalah</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: dari sistem Linear Time-Invariant (LTI) waktu kontinu dengan input x(t) dan respons impuls sistem h(t)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: konvolusi</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Output y(t) dari sistem Linear Time-Invariant (LTI) waktu kontinu adalah konvolusi dari input x(t) dan respons impuls sistem h(t).</td>
</tr>
<tr class="odd">
<td>23. <strong>SISTEM-RESPONS-IMPULS-DIRAC</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Output yang dihasilkan sistem</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: adalah</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: jika input yang diberikan ke sistem adalah impuls Dirac (δ(t))</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: respons impuls h(t)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Jika input yang diberikan ke sistem adalah impuls Dirac (δ(t)), output yang dihasilkan sistem adalah respons impuls h(t).</td>
</tr>
<tr class="odd">
<td>24. <strong>OUTPUT-DT-LTI-KONVOLUSI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Output y[n]</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: adalah</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: dari sistem LTI waktu diskrit dengan input x[n] dan respons impuls sistem h[n]</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: konvolusi</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Output y[n] dari sistem LTI waktu diskrit adalah konvolusi dari input x[n] dan respons impuls sistem h[n].</td>
</tr>
<tr class="odd">
<td>25. <strong>OUTPUT-FREKUENSI-CTFT-PERKALIAN</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Output Y(jω)</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: adalah</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (ketika menggunakan CTFT)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: perkalian dari Transformasi Fourier input X(jω) dan respons frekuensi sistem H(jω)</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Output Y(jω) adalah perkalian dari Transformasi Fourier input X(jω) dan respons frekuensi sistem H(jω).</td>
</tr>
<tr class="odd">
<td>26. <strong>ANALISIS-LTI-EFISIEN-FREKUENSI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Analisis sistem LTI</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: menjadi efisien</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: di domain frekuensi</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: karena sifat fundamental Transformasi Fourier yang mengubah operasi konvolusi di domain waktu menjadi perkalian di domain frekuensi</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Efisiensi analisis sistem LTI di domain frekuensi berasal dari sifat fundamental Transformasi Fourier yang mengubah operasi konvolusi di domain waktu menjadi perkalian di domain frekuensi.</td>
</tr>
<tr class="odd">
<td>27. <strong>LAPLACE-EFEKTIF-PD-ALJABAR</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Transformasi Laplace</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: menjadi sangat efektif</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (ketika diterapkan pada) persamaan diferensial linear</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: karena mengubahnya menjadi persamaan aljabar yang jauh lebih mudah dipecahkan</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Transformasi Laplace sangat efektif karena mengubah persamaan diferensial linear menjadi persamaan aljabar, yang jauh lebih mudah dipecahkan.</td>
</tr>
<tr class="odd">
<td>28. <strong>Z-TRANSFORM-UBAH-PB-ALJABAR</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Transformasi Z</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: mengubah</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: persamaan beda</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: menjadi persamaan aljabar, menyederhanakan penyelesaian</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Transformasi Z mengubah persamaan beda menjadi persamaan aljabar, menyederhanakan penyelesaian.</td>
</tr>
<tr class="odd">
<td>29. <strong>PETA-PENGETAHUAN-IMPLIKASI-PEMBELAJARAN</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Peta pengetahuan</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: memiliki implikasi besar</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (ketika digunakan)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: untuk pembelajaran dan aplikasi praktis di bidang teknik</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Peta pengetahuan yang diuraikan dalam laporan ini memiliki implikasi besar untuk pembelajaran dan aplikasi praktis di bidang teknik.</td>
</tr>
<tr class="odd">
<td>30. <strong>PETA-MEMUNGKINKAN-GAMBARAN-BESAR</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Peta ini</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: memungkinkan</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: individu (yang menggunakannya)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: untuk “melihat gambaran besar” dan mengorganisir pengetahuan mereka dengan cara yang memfasilitasi pemahaman, pengambilan, dan aplikasi</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Peta ini memungkinkan individu untuk “melihat gambaran besar” dan mengorganisir pengetahuan mereka dengan cara yang memfasilitasi pemahaman, pengambilan, dan aplikasi.</td>
</tr>
<tr class="odd">
<td>31. <strong>AI-KURANGI-UPAYA-PETA</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: AI</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: dapat mengurangi</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (ketika digunakan untuk) membuat peta pengetahuan</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: upaya manual yang diperlukan untuk membuat peta pengetahuan yang komprehensif dari buku teks, catatan kuliah, atau makalah penelitian</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> AI dapat mengurangi upaya manual yang diperlukan untuk membuat peta pengetahuan yang komprehensif dari buku teks, catatan kuliah, atau makalah penelitian.</td>
</tr>
<tr class="odd">
<td>32. <strong>AI-PERSONALISASI-PETA-BELAJAR</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: AI</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: dapat menyesuaikan</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: kompleksitas dan fokus peta berdasarkan gaya belajar atau tingkat pemahaman individu</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: menciptakan jalur pembelajaran yang dipersonalisasi</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> AI dapat menyesuaikan kompleksitas dan fokus peta berdasarkan gaya belajar atau tingkat pemahaman individu, menciptakan jalur pembelajaran yang dipersonalisasi.</td>
</tr>
<tr class="odd">
<td>33. <strong>PETA-AI-INTERAKTIF-IDENTIFIKASI-GAP</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Peta pengetahuan yang didukung AI</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: dapat menjadi interaktif</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: (ketika digunakan)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: memungkinkan pengguna untuk mengajukan pertanyaan dalam bahasa alami, menjelajahi hubungan, dan mengidentifikasi kesenjangan pengetahuan secara dinamis</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Peta pengetahuan yang didukung AI dapat menjadi interaktif, memungkinkan pengguna untuk mengajukan pertanyaan dalam bahasa alami, menjelajahi hubungan, dan mengidentifikasi kesenjangan pengetahuan secara dinamis.</td>
</tr>
<tr class="odd">
<td>34. <strong>PETA-AI-PANDU-SOLUSI</strong></td>
</tr>
<tr class="even">
<td>- <strong>A</strong>ktor: Peta berbasis AI</td>
</tr>
<tr class="odd">
<td>- <strong>B</strong>erperilaku: dapat memandu</td>
</tr>
<tr class="even">
<td>- <strong>C</strong>ondisi: pengguna (dalam pemecahan masalah)</td>
</tr>
<tr class="odd">
<td>- <strong>D</strong>erajat: melalui langkah-langkah pemecahan masalah, menyarankan formula atau transformasi yang relevan, dan bahkan membantu mengidentifikasi miskonsepsi umum</td>
</tr>
<tr class="even">
<td>- <strong>Pernyataan Lengkap:</strong> Peta berbasis AI dapat memandu pengguna melalui langkah-langkah pemecahan masalah, menyarankan formula atau transformasi yang relevan, dan bahkan membantu mengidentifikasi miskonsepsi umum.</td>
</tr>
</tbody>
</table>
</section>
<section id="peta-pengetahuan-primitif-primitive-knowledge-map" class="level1">
<h1>Peta Pengetahuan Primitif (Primitive Knowledge Map)</h1>
<p>Peta Pengetahuan Primitif adalah representasi statis dari konsep-konsep inti dalam mata kuliah Sinyal dan Sistem, berfungsi sebagai “ensiklopedia” atau referensi material yang berisi definisi, properti, dan hubungan fundamental. Peta ini distrukturkan secara hierarkis, dimulai dengan “Sinyal &amp; Sistem” sebagai node pusat, kemudian bercabang ke domain-domain utama (Waktu, Frekuensi, Kompleks).</p>
<section id="peta-ringkasan-konsep-dasar" class="level2">
<h2 class="anchored" data-anchor-id="peta-ringkasan-konsep-dasar">Peta Ringkasan Konsep Dasar</h2>
<p>Berikut adalah diagram konseptual menggunakan Mermaid:</p>
<pre><code>graph TD
    A[Sinyal &amp; Sistem] --&gt; B(Kawasan Waktu)
    A --&gt; C(Kawasan Frekuensi)
    A --&gt; D(Kawasan Kompleks)

    B --&gt; B1(Sinyal Waktu Kontinu)
    B --&gt; B2(Sinyal Waktu Diskrit)
    B --&gt; B3(Sistem)
    B1 -- memiliki properti --&gt; B1a(Periodik)
    B1 -- memiliki properti --&gt; B1b(Aperiodik)
    B1 -- memiliki properti --&gt; B1c(Energi/Daya)
    B2 -- memiliki properti --&gt; B2a(Periodik)
    B2 -- memiliki properti --&gt; B2b(Aperiodik)
    B2 -- memiliki properti --&gt; B2c(Energi/Daya)
    B3 -- memiliki properti --&gt; B3a(Linearitas)
    B3 -- memiliki properti --&gt; B3b(Invariansi Waktu)
    B3 -- memiliki properti --&gt; B3c(Kausalitas)
    B3 -- memiliki properti --&gt; B3d(Stabilitas BIBO)
    B3 -- dapat direpresentasikan sebagai --&gt; B3e(Persamaan Diferensial)
    B3 -- dapat direpresentasikan sebagai --&gt; B3f(Persamaan Beda)
    B3 -- dapat direpresentasikan sebagai --&gt; B3g(Diagram Blok)

    C --&gt; C1(Deret Fourier)
    C --&gt; C2(Transformasi Fourier Waktu Kontinu - CTFT)
    C --&gt; C3(Transformasi Fourier Waktu Diskrit - DTFT)
    C1 -- merepresentasikan --&gt; B1a
    C2 -- mengubah --&gt; B1
    C2 -- mengubah konvolusi di domain waktu menjadi --&gt; C2a(Perkalian di domain frekuensi)
    C3 -- mengubah --&gt; B2

    D --&gt; D1(Transformasi Laplace)
    D --&gt; D2(Transformasi Z)
    D1 -- mengubah --&gt; B1
    D1 -- menganalisis stabilitas melalui --&gt; D1a(Pole di bidang kiri)
    D1 -- mengubah PD linear menjadi --&gt; D1b(Persamaan Aljabar)
    D2 -- mengubah --&gt; B2
    D2 -- menganalisis stabilitas melalui --&gt; D2a(Pole di dalam lingkaran unit)
    D2 -- mengubah PB menjadi --&gt; D2b(Persamaan Aljabar)

    B --&gt; E(Konvolusi)
    C --&gt; E
    D --&gt; E
    E -- menjelaskan hubungan Input-Output Sistem LTI --&gt; B3a
    E -- menjelaskan hubungan Input-Output Sistem LTI --&gt; B3b

    A -- menjembatani domain --&gt; F(Sampling)
    F -- menghindari --&gt; F1(Aliasing)
    F1 -- diatur oleh --&gt; F2(Teorema Nyquist-Shannon)</code></pre>
</section>
<section id="penjelasan-diagram-peta-pengetahuan-primitif" class="level2">
<h2 class="anchored" data-anchor-id="penjelasan-diagram-peta-pengetahuan-primitif">Penjelasan Diagram Peta Pengetahuan Primitif:</h2>
<ul>
<li><strong>Node Utama:</strong> <code>A[Sinyal &amp; Sistem]</code> adalah konsep sentral yang mencakup keseluruhan mata kuliah.</li>
<li><strong>Domain:</strong> Bercabang menjadi tiga domain utama: <code>B(Kawasan Waktu)</code>, <code>C(Kawasan Frekuensi)</code>, dan <code>D(Kawasan Kompleks)</code>.</li>
<li><strong>Konsep Spesifik:</strong> Di bawah setiap domain, terdapat konsep-konsep kunci seperti Sinyal Waktu Kontinu/Diskrit, Sistem, Deret Fourier, dan Transformasi.</li>
<li><strong>Hubungan:</strong> Panah berlabel menunjukkan hubungan antar konsep, seperti “memiliki properti”, “mengubah”, “merepresentasikan”, atau “menjelaskan hubungan”. Contohnya, sistem memiliki properti linearitas, dan transformasi Fourier mengubah sinyal domain waktu.</li>
<li><strong>Konvolusi:</strong> Ditunjukkan sebagai konsep sentral yang berlaku di beberapa domain dan menjelaskan hubungan input-output sistem LTI.</li>
<li><strong>Sampling:</strong> Ditunjukkan sebagai konsep yang menjembatani antar domain (terutama waktu kontinu dan diskrit) dan relevansinya dengan aliasing dan teorema Nyquist-Shannon.</li>
</ul>
<hr>
</section>
</section>
<section id="peta-pemecahan-masalah-problem-solving-knowledge-map" class="level1">
<h1>Peta Pemecahan Masalah (Problem-Solving Knowledge Map)</h1>
<p>Peta Pemecahan Masalah bersifat dinamis dan berorientasi proses, bertindak sebagai “GPS” yang memandu mahasiswa dari informasi yang diketahui (Titik Mulai) ke solusi yang dicari (Titik Akhir) menggunakan langkah-langkah prosedural dan “kendaraan” (alat atau metode). Ini sering kali menyerupai <em>flowchart</em> dengan titik keputusan.</p>
<section id="peta-ringkasan-pemecahan-masalah" class="level2">
<h2 class="anchored" data-anchor-id="peta-ringkasan-pemecahan-masalah">Peta Ringkasan Pemecahan Masalah</h2>
<p>Berikut adalah diagram konseptual menggunakan Mermaid, dengan contoh spesifik masalah analisis stabilitas dan respons impuls sistem LTI:</p>
<pre><code>graph TD
    start[Titik Mulai: Informasi yang Diketahui] --&gt; A{Apakah Sistem Kontinu atau Diskrit?}

    A -- Kontinu --&gt; B(Pilih Rute: Analisis Domain Laplace)
    A -- Diskrit --&gt; C(Pilih Rute: Analisis Domain Z)

    B --&gt; B1(Transformasikan Persamaan Diferensial)
    C --&gt; C1(Transformasikan Persamaan Beda)

    B1 -- Gunakan Kendaraan --&gt; V1["Kendaraan: Transformasi Laplace (K_MAT_TransLaplace)"]
    C1 -- Gunakan Kendaraan --&gt; V2["Kendaraan: Transformasi Z (K_MAT_TransZ)"]

    V1 --&gt; D(Dapatkan Fungsi Transfer H(s))
    V2 --&gt; E(Dapatkan Fungsi Transfer H(z))

    D --&gt; F(Analisis Pole/Zero)
    E --&gt; G(Analisis Pole/Zero)

    F -- Gunakan Kendaraan --&gt; V3["Kendaraan: Plot Pole-Zero (K_VIS_PoleZeroPlot)"]
    G -- Gunakan Kendaraan --&gt; V3

    F --&gt; H{Periksa Stabilitas (Pole di Bidang Kiri?)}
    G --&gt; I{Periksa Stabilitas (Pole di dalam Lingkaran Unit?)}

    H -- Ya --&gt; J(Lanjutkan ke Transformasi Invers)
    H -- Tidak --&gt; K(Identifikasi Sistem Tidak Stabil)
    I -- Ya --&gt; J
    I -- Tidak --&gt; K

    J -- Gunakan Kendaraan --&gt; V4["Kendaraan: Transformasi Laplace Invers / Transformasi Z Invers (K_MAT_TransInv)"]
    K -- Gunakan Kendaraan --&gt; V5["Kendaraan: Heuristik (Menggambar Diagram, Mencari Pola)"]

    J --&gt; end[Titik Akhir: Stabilitas Sistem &amp; Respons Impuls Ditemukan]
    K --&gt; end</code></pre>
</section>
<section id="penjelasan-diagram-peta-pemecahan-masalah" class="level2">
<h2 class="anchored" data-anchor-id="penjelasan-diagram-peta-pemecahan-masalah">Penjelasan Diagram Peta Pemecahan Masalah</h2>
<ul>
<li><strong>Titik Mulai &amp; Akhir:</strong> <code>start</code> merepresentasikan informasi awal masalah (misalnya, deskripsi sistem berupa persamaan diferensial/beda) dan <code>end</code> adalah tujuan (menentukan stabilitas dan respons impuls).</li>
<li><strong>Titik Keputusan:</strong> Dilambangkan dengan bentuk berlian (<code>{}</code>), seperti <code>A{Apakah Sistem Kontinu atau Diskrit?}</code>. Ini mewakili pilihan strategis yang perlu dibuat berdasarkan karakteristik masalah.</li>
<li><strong>Langkah Prosedural (Rute/Jalan):</strong> Dilambangkan dengan bentuk persegi panjang (<code>()</code>), menunjukkan tahapan yang harus dilalui, seperti “Transformasikan Persamaan Diferensial”.</li>
<li><strong>Kendaraan (Vehicles):</strong> Ditunjukkan dengan bentuk persegi panjang dengan label mnemonik “Kendaraan:” dan nama alat/metode, seperti <code>V1["Kendaraan: Transformasi Laplace (K_MAT_TransLaplace)"]</code>. Ini adalah alat yang digunakan untuk berpindah dari satu tahap ke tahap berikutnya. Heuristik juga digambarkan sebagai “meta-kendaraan” strategis.</li>
</ul>
<p>Kedua peta ini saling melengkapi: Peta Primitif menyediakan “apa” dan “mengapa” dari konsep-konsep, sementara Peta Pemecahan Masalah menyediakan “bagaimana” untuk menerapkan konsep-konsep tersebut dalam menyelesaikan tantangan rekayasa.</p>
</section>
</section>
     </main>
<!-- /main column -->  <script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>  </div> <!-- /content --> 
  
</body></html>